{
    "connections": [
        {
            "in_id": "{220317cf-177d-4ebb-b02b-ae0fc58623ed}",
            "in_index": 1,
            "out_id": "{3da86de6-0fa5-4d1b-bd49-5629629c4714}",
            "out_index": 0
        },
        {
            "in_id": "{284527bb-f78f-4c95-a983-f61c34198a08}",
            "in_index": 0,
            "out_id": "{220317cf-177d-4ebb-b02b-ae0fc58623ed}",
            "out_index": 0
        },
        {
            "in_id": "{220317cf-177d-4ebb-b02b-ae0fc58623ed}",
            "in_index": 0,
            "out_id": "{07766b88-0e71-4e8f-843d-36df2ba92935}",
            "out_index": 0
        }
    ],
    "nodes": [
        {
            "id": "{3da86de6-0fa5-4d1b-bd49-5629629c4714}",
            "model": {
                "functionCode": "float sdPlane(vec3 _p, float _y)\n{\n   return _p.y - _y;\n}\n",
                "name": "Infinite Plane",
                "shaderCode": "float plane = sdPlane(_p, 0);\n",
                "variableName": "plane",
                "yPos": 0
            },
            "position": {
                "x": -785,
                "y": 156
            }
        },
        {
            "id": "{07766b88-0e71-4e8f-843d-36df2ba92935}",
            "model": {
                "functionCode": "float sdSphere(vec3 _p, vec3 _pos, float _r)\n{\n   vec4 sphere = vec4(_pos, _r);\n   return length(_p - sphere.xyz) - sphere.w;\n}\n",
                "name": "Sphere",
                "radius": 1,
                "shaderCode": "float sphere = sdSphere(_p, vec3(0, 1, 5), 1);\n",
                "variableName": "sphere",
                "xPos": 0,
                "yPos": 1,
                "zPos": 5
            },
            "position": {
                "x": -914.1119999999996,
                "y": -133.05599999999995
            }
        },
        {
            "id": "{220317cf-177d-4ebb-b02b-ae0fc58623ed}",
            "model": {
                "functionCode": "float sdSphere(vec3 _p, vec3 _pos, float _r)\n{\n   vec4 sphere = vec4(_pos, _r);\n   return length(_p - sphere.xyz) - sphere.w;\n}\nfloat sdPlane(vec3 _p, float _y)\n{\n   return _p.y - _y;\n}\n",
                "name": "Union",
                "shaderCode": "float sphere = sdSphere(_p, vec3(0, 1, 5), 1);\nfloat plane = sdPlane(_p, 0);\ndistance = min(sphere, plane);\n",
                "shapeA": "sphere",
                "shapeAFunctionCode": "float sdSphere(vec3 _p, vec3 _pos, float _r)\n{\n   vec4 sphere = vec4(_pos, _r);\n   return length(_p - sphere.xyz) - sphere.w;\n}\n",
                "shapeAShaderCode": "float sphere = sdSphere(_p, vec3(0, 1, 5), 1);\n",
                "shapeB": "plane",
                "shapeBFunctionCode": "float sdPlane(vec3 _p, float _y)\n{\n   return _p.y - _y;\n}\n",
                "shapeBShaderCode": "float plane = sdPlane(_p, 0);\n",
                "variableName": "0"
            },
            "position": {
                "x": -342.14399999999995,
                "y": 10.367999999999995
            }
        },
        {
            "id": "{284527bb-f78f-4c95-a983-f61c34198a08}",
            "model": {
                "ROxPos": 0,
                "ROyPos": 1,
                "ROzPos": 0,
                "lightxPos": 0,
                "lightyPos": 3,
                "lightzPos": 5,
                "name": "Ray March",
                "shaderCode": "#define MAX_STEPS 100\n#define MAX_DISTANCE 100.0\n#define SURFACE_DISTANCE 0.01\n\nfloat sdSphere(vec3 _p, vec3 _pos, float _r)\n{\n   vec4 sphere = vec4(_pos, _r);\n   return length(_p - sphere.xyz) - sphere.w;\n}\nfloat sdPlane(vec3 _p, float _y)\n{\n   return _p.y - _y;\n}\n\nfloat GetDistance(vec3 _p)\n{\nfloat distance = 1000;\nfloat sphere = sdSphere(_p, vec3(0, 1, 5), 1);\nfloat plane = sdPlane(_p, 0);\ndistance = min(sphere, plane);\n\n   // Return distance of closest scene object\n  if (distance == 1000)\n  {\n    return 0;\n  }\n   return distance;\n}\n\nfloat RayMarch(vec3 _rayOrigin, vec3 _rayDirection)\n{\n   float originDistance = 0.0;\n   for (int i = 0; i < MAX_STEPS; i++)\n   {\n       // Marching point\n       vec3 p = _rayOrigin + (originDistance * _rayDirection);\n\n       // Calculate distance from current point (p) to scene object\n       float sceneDistance = GetDistance(p);\n       originDistance += sceneDistance;\n\n       // Scene has been hit, or surpassed MAX_DISTANCE\n       if (sceneDistance < SURFACE_DISTANCE || originDistance > MAX_DISTANCE)\n       {\n           break;\n       }\n   }\n   return originDistance;\n}\n\nvec3 GetNormal(vec3 _p)\n{\n    // Distance from point _p to surface\n    float surfaceDistance = GetDistance(_p);\n\n    // Distance to sample surrounding points\n    vec2 threshold = vec2(0.01, 0);\n\n    // Sample points\n    vec3 normal = surfaceDistance - vec3(GetDistance(_p - threshold.xyy),\n                                       GetDistance(_p - threshold.yxy),\n                                       GetDistance(_p - threshold.yyx));\n\n    return normalize(normal);\n}\n\nfloat GetLight(vec3 _p)\n{\n   // Define light\n   vec3 lightPosition = vec3(0, 3, 5);\n   lightPosition.xz += vec2(sin(iTime), cos(iTime)) * 2;\n   vec3 lightVector = normalize(lightPosition - _p);\n\n   // Calculate normal of intersection point\n   vec3 normal = GetNormal(_p);\n\n   // Clamp diffuse value from -1 to 1, -> 0 to 1\n   float diffuse = clamp(dot(normal, lightVector), 0.0, 1.0);\n\n   // Calculate distance between _p and light source\n   float lightDistance = RayMarch(_p + (normal * SURFACE_DISTANCE * 2.0), lightVector);\n\n   // Hit something\n   if (lightDistance < length(lightPosition - _p))\n   {\n       diffuse *= 0.1;\n   }\n\n   return diffuse;\n}\n\nvoid main()\n{\n   // Normalize pixel coordinates (from -0.5 to 0.5), flip y\n   vec2 uv = vec2(iUV.x - 0.5, (iUV.y - 0.5) * -1);\n\n   // Default black\n   vec3 colour = vec3(0);\n\n   // Camera setup\n   vec3 rayOrigin = vec3(0, 1, 0);\n   vec3 rayDirection = normalize(vec3(uv.x, uv.y, 1));\n\n   // Fire rays, return distance to intersection\n   float rayDistance = RayMarch(rayOrigin, rayDirection);\n\n   // Get point of intersection\n   vec3 p = rayOrigin + (rayDirection * rayDistance);\n\n   // Calculate lighting and shadows\n   float diffuse = GetLight(p);\n   colour = vec3(diffuse);\n\n   fragColour = vec4(colour, 1.0);\n}\n"
            },
            "position": {
                "x": -26,
                "y": -5
            }
        }
    ]
}
